generator bit atom_bit (bit a, bit b) {
    int t = ??(2);
    if(t == 0) {
        return !a || b;
    }
    if(t == 1) {
        return !b || a;
    }
    return 1;
}

generator bit atom_int (int a, int b) {
    int t = ??(3);
    if(t == 0) {
        return a == b;
    }
    if(t == 1) {
        return a <= b;
    }
    if(t == 2) {
        return a < b;
    }
    if(t == 3) {
        return a >= b;
    }
    if(t == 4) {
        return a > b;
    }
    return 1;
}

struct bt_0 {
    int v0;
    int v1;
    int v2;
}
struct bt_1 {
    int v0;
}
struct bt_2 {
    bit v0;
}
bit eq_bt_1 (bt_1 a, bt_1 b) {
    return a.v0 == b.v0;
}

bit compare_bt_1 (bt_1 a, bt_1 b) {
    bit leq = 0;
    repeat(??) {
        leq = leq || disjunct_bt_1(a, b);
    }
    return leq;
}

generator bit disjunct_bt_1 (bt_1 a, bt_1 b) {
    return atom_int(a.v0, b.v0);
}

harness void not_equivalence_bt_1 () {
    bt_1 a = new bt_1(v0 = ??);
    bt_1 b = new bt_1(v0 = ??);
    assert(!eq_bt_1(a, b));
    assert(compare_bt_1(a, b));
}

bit eq_bt_2 (bt_2 a, bt_2 b) {
    return a.v0 == b.v0;
}

bit compare_bt_2 (bt_2 a, bt_2 b) {
    bit leq = 0;
    repeat(??) {
        leq = leq || disjunct_bt_2(a, b);
    }
    return leq;
}

generator bit disjunct_bt_2 (bt_2 a, bt_2 b) {
    return atom_bit(a.v0, b.v0);
}

harness void not_equivalence_bt_2 () {
    bt_2 a = new bt_2(v0 = ??);
    bt_2 b = new bt_2(v0 = ??);
    assert(!eq_bt_2(a, b));
    assert(compare_bt_2(a, b));
}

bt_1 prod_0_sem_0 (bt_0 b0, bt_2 b2, bt_1 b3, bt_1 b4) {
    return new bt_1(v0 = b2.v0 ? b3.v0 : b4.v0);
}

bt_2 prod_4_sem_0 (bt_0 b0, bt_1 b2, bt_1 b3) {
    return new bt_2(v0 = b2.v0 < b3.v0);
}

harness void main (int bt_0_0_0, int bt_0_0_1, int bt_0_0_2, int bt_1_0_0, int bt_1_1_0, int bt_1_2_0, bit bt_2_0_0, bit bt_2_1_0, bit bt_2_2_0) {
    bt_0 bt_0_0 = new bt_0(v0 = bt_0_0_0, v1 = bt_0_0_1, v2 = bt_0_0_2);
    bt_1 bt_1_0 = new bt_1(v0 = bt_1_0_0);
    bt_1 bt_1_1 = new bt_1(v0 = bt_1_1_0);
    bt_1 bt_1_2 = new bt_1(v0 = bt_1_2_0);
    bt_2 bt_2_0 = new bt_2(v0 = bt_2_0_0);
    bt_2 bt_2_1 = new bt_2(v0 = bt_2_1_0);
    bt_2 bt_2_2 = new bt_2(v0 = bt_2_2_0);
    
    // bt_1: reflexivity and antisymmetry
    assert((compare_bt_1(bt_1_0, bt_1_1) && compare_bt_1(bt_1_1, bt_1_0)) == eq_bt_1(bt_1_0, bt_1_1));
    // bt_1: transitivity
    assert(!compare_bt_1(bt_1_0, bt_1_1) || !compare_bt_1(bt_1_1, bt_1_2) || compare_bt_1(bt_1_0, bt_1_2));
    
    // bt_2: reflexivity and antisymmetry
    assert((compare_bt_2(bt_2_0, bt_2_1) && compare_bt_2(bt_2_1, bt_2_0)) == eq_bt_2(bt_2_0, bt_2_1));
    // bt_2: transitivity
    assert(!compare_bt_2(bt_2_0, bt_2_1) || !compare_bt_2(bt_2_1, bt_2_2) || compare_bt_2(bt_2_0, bt_2_2));
    int cost = 0;
    int prod_0_sem_0_mono_2 = ??(2) /*#MONO prod_0_sem_0.2*/;
    if(prod_0_sem_0_mono_2 == 0) {
        assert(!compare_bt_2(bt_2_0, bt_2_1) || compare_bt_1(prod_0_sem_0(bt_0_0, bt_2_0, bt_1_0, bt_1_1), prod_0_sem_0(bt_0_0, bt_2_1, bt_1_0, bt_1_1)));
    }
    else 
    if(prod_0_sem_0_mono_2 == 1) {
        assert(!compare_bt_2(bt_2_0, bt_2_1) || compare_bt_1(prod_0_sem_0(bt_0_0, bt_2_1, bt_1_0, bt_1_1), prod_0_sem_0(bt_0_0, bt_2_0, bt_1_0, bt_1_1)));
    }
    else {
        cost = cost + 1;
    }
    int prod_0_sem_0_mono_3 = ??(2) /*#MONO prod_0_sem_0.3*/;
    if(prod_0_sem_0_mono_3 == 0) {
        assert(!compare_bt_1(bt_1_0, bt_1_1) || compare_bt_1(prod_0_sem_0(bt_0_0, bt_2_0, bt_1_0, bt_1_2), prod_0_sem_0(bt_0_0, bt_2_0, bt_1_1, bt_1_2)));
    }
    else 
    if(prod_0_sem_0_mono_3 == 1) {
        assert(!compare_bt_1(bt_1_0, bt_1_1) || compare_bt_1(prod_0_sem_0(bt_0_0, bt_2_0, bt_1_1, bt_1_2), prod_0_sem_0(bt_0_0, bt_2_0, bt_1_0, bt_1_2)));
    }
    else {
        cost = cost + 1;
    }
    int prod_0_sem_0_mono_4 = ??(2) /*#MONO prod_0_sem_0.4*/;
    if(prod_0_sem_0_mono_4 == 0) {
        assert(!compare_bt_1(bt_1_1, bt_1_2) || compare_bt_1(prod_0_sem_0(bt_0_0, bt_2_0, bt_1_0, bt_1_1), prod_0_sem_0(bt_0_0, bt_2_0, bt_1_0, bt_1_2)));
    }
    else 
    if(prod_0_sem_0_mono_4 == 1) {
        assert(!compare_bt_1(bt_1_1, bt_1_2) || compare_bt_1(prod_0_sem_0(bt_0_0, bt_2_0, bt_1_0, bt_1_2), prod_0_sem_0(bt_0_0, bt_2_0, bt_1_0, bt_1_1)));
    }
    else {
        cost = cost + 1;
    }
    int prod_4_sem_0_mono_2 = ??(2) /*#MONO prod_4_sem_0.2*/;
    if(prod_4_sem_0_mono_2 == 0) {
        assert(!compare_bt_1(bt_1_0, bt_1_1) || compare_bt_2(prod_4_sem_0(bt_0_0, bt_1_0, bt_1_2), prod_4_sem_0(bt_0_0, bt_1_1, bt_1_2)));
    }
    else 
    if(prod_4_sem_0_mono_2 == 1) {
        assert(!compare_bt_1(bt_1_0, bt_1_1) || compare_bt_2(prod_4_sem_0(bt_0_0, bt_1_1, bt_1_2), prod_4_sem_0(bt_0_0, bt_1_0, bt_1_2)));
    }
    else {
        cost = cost + 1;
    }
    int prod_4_sem_0_mono_3 = ??(2) /*#MONO prod_4_sem_0.3*/;
    if(prod_4_sem_0_mono_3 == 0) {
        assert(!compare_bt_1(bt_1_1, bt_1_2) || compare_bt_2(prod_4_sem_0(bt_0_0, bt_1_0, bt_1_1), prod_4_sem_0(bt_0_0, bt_1_0, bt_1_2)));
    }
    else 
    if(prod_4_sem_0_mono_3 == 1) {
        assert(!compare_bt_1(bt_1_1, bt_1_2) || compare_bt_2(prod_4_sem_0(bt_0_0, bt_1_0, bt_1_2), prod_4_sem_0(bt_0_0, bt_1_0, bt_1_1)));
    }
    else {
        cost = cost + 1;
    }
    minimize(cost);
}

