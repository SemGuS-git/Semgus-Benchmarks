// AUTO GENERATED by ImperativeExampleConverter from SAS_04_sigmaSquareTests.json
// no04_sigmaSquare_02
(synth-fun _fact ((n Int) (r Int) (t1 Int)) ((r_out Int))

(
    _Entry : (_Entry.Sem (Term Int Int Int Int)) : t
    [() (_Entry.Sem t n r t1 r_out)]
    (
        (Eval Start:_term0) [( (n_out Int) (t1_out Int)) (and
            (= t (Eval _term0))
            (Start.Sem _term0 n r t1 n_out r_out t1_out)
        )]
    )
)
(

    A : (A.Sem (Term Int Int Int Int)) : t
    [( (_result Int)) (A.Sem t n r t1 _result)]
    (

        // A ::= IntSingleTerm $r

        prod8 [() (and (= t (Leaf 'r')) (= _result r))]

        // A ::= IntSingleTerm $n

        prod7 [() (and (= t (Leaf 'n')) (= _result n))]

        // A ::= IntSingleTerm $t1

        prod13 [() (and (= t (Leaf 't1')) (= _result t1))]
    )
)
(

    Start : (Start.Sem (Term Int Int Int Int Int Int)) : t
    [( (n_out Int) (t1_out Int)) (Start.Sem t n r t1 n_out r_out t1_out)]
    (

        // Start ::= While @B @S

        (prod0 B:_term0 S:_term1) [((_cond Bool) (n_temp Int) (r_temp Int) (t1_temp Int)) (and
            (= t (While _term0 _term1))
            (B.Sem _term0 n r t1 _cond)
            (= _cond true)
            (S.Sem _term1 n r t1 n_temp r_temp t1_temp)
            (Start.Sem t n_temp r_temp t1_temp n_out r_out t1_out)
        )]
        (prod0 B:_term0 S:_term1) [((_cond Bool)) (and
            (= t (While _term0 _term1))
            (B.Sem _term0 n r t1 _cond)
            (= _cond false)
            (= n_out n) (= r_out r) (= t1_out t1)
        )]
    )
)
(

    E : (E.Sem (Term Int Int Int Int)) : t
    [( (_result Int)) (E.Sem t n r t1 _result)]
    (

        // E ::= Mult @A @A

        (prod11 A:_term0 A:_term1) [((_term0_val Int) (_term1_val Int)) (and
            (= t (Mult _term0 _term1))
            (A.Sem _term0 n r t1 _term0_val) (A.Sem _term1 n r t1 _term1_val)
            (= _result (* _term0_val _term1_val))
        )]

        // E ::= Minus @A @A

        (prod10 A:_term0 A:_term1) [((_term0_val Int) (_term1_val Int)) (and
            (= t (Minus _term0 _term1))
            (A.Sem _term0 n r t1 _term0_val) (A.Sem _term1 n r t1 _term1_val)
            (= _result (- _term0_val _term1_val))
        )]

        // E ::= Plus @A @A

        (prod9 A:_term0 A:_term1) [((_term0_val Int) (_term1_val Int)) (and
            (= t (Plus _term0 _term1))
            (A.Sem _term0 n r t1 _term0_val) (A.Sem _term1 n r t1 _term1_val)
            (= _result (+ _term0_val _term1_val))
        )]
    )
)
(

    S : (S.Sem (Term Int Int Int Int Int Int)) : t
    [( (n_out Int) (t1_out Int)) (S.Sem t n r t1 n_out r_out t1_out)]
    (

        // S ::= Seq @S @S

        (prod2 S:_term0 S:_term1) [((n_temp Int) (r_temp Int) (t1_temp Int)) (and
            (= t (Seq _term0 _term1))
            (S.Sem _term0 n r t1 n_temp r_temp t1_temp)
            (S.Sem _term1 n_temp r_temp t1_temp n_out r_out t1_out)
        )]

        // S ::= IntAssign $t1 @E

        (prod12 E:_term0) [((_temp Int)) (and 
            (= t (IntAssign 't1' _term0))
            (E.Sem _term0 n r t1 _temp)
            (= n_out n) (= r_out r) (= t1_out _temp)
        )]

        // S ::= IntAssign $r @E

        (prod4 E:_term0) [((_temp Int)) (and 
            (= t (IntAssign 'r' _term0))
            (E.Sem _term0 n r t1 _temp)
            (= n_out n) (= r_out _temp) (= t1_out t1)
        )]

        // S ::= IntAssign $n @E

        (prod3 E:_term0) [((_temp Int)) (and 
            (= t (IntAssign 'n' _term0))
            (E.Sem _term0 n r t1 _temp)
            (= n_out _temp) (= r_out r) (= t1_out t1)
        )]
    )
)
(

    B : (B.Sem (Term Int Int Int Bool)) : t
    [( (_result Bool)) (B.Sem t n r t1 _result)]
    (

        // B ::= LT @A @A

        (prod1 A:_term0 A:_term1) [((_term0_val Int) (_term1_val Int)) (and
            (= t (LT _term0 _term1))
            (A.Sem _term0 n r t1 _term0_val) (A.Sem _term1 n r t1 _term1_val)
            (= _result (< _term0_val _term1_val))
        )]
    )
)
)

(constraint
    (and
        (_Entry.Sem t 1 0 0 1) // { n: 1, r: 0, } -> { r: 1, }
        (_Entry.Sem t 2 0 0 5) // { n: 2, r: 0, } -> { r: 5, }
        (_Entry.Sem t 3 0 0 14) // { n: 3, r: 0, } -> { r: 14, }
    )
)
