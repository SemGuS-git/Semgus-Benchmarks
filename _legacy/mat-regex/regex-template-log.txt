{% macro str(name) %}{% for i in range(0,n) %}{{name}}_{{i}} {%endfor%}{%endmacro%}
{% macro mat(name) %}{% for i in range(0,n+1) %}{% for j in range (i, n+1) %}{{name}}_{{i}}_{{j}} {%endfor%}{%endfor%}{%endmacro%}
{% macro dec_str(name) %}{% for i in range(0,n) %}({{name}}_{{i}} Int) {%endfor%}{%endmacro%}
{% macro dec_mat(name) %}{% for i in range(0,n+1) %}{% for j in range (i, n+1) %}({{name}}_{{i}}_{{j}} Bool) {%endfor%}{%endfor%}{%endmacro%}
{% macro t_str() %}{%for i in range(0,n)%}Int {%endfor%}{%endmacro%}
{% macro t_mat() %}{% for i in range(0,n+1) %}{% for j in range (i, n+1) %}Bool {%endfor%}{%endfor%}{%endmacro%}

{% macro eq_false(name) %}{% for i in range(0,n+1) %}{% for j in range (i, n+1) %}(= {{name}}_{{i}}_{{j}} false) {%endfor%}{%endfor%}{%endmacro%}
{% macro eq_id(name) %}{% for i in range(0,n+1) %}{% for j in range (i, n+1) %}(= {{name}}_{{i}}_{{j}} {% if (i==j) %}true{%else%}false{%endif%}) {%endfor%}{%endfor%}{%endmacro%}
{% macro eq_any(name) %}{% for i in range(0,n+1) %}{% for j in range (i, n+1) %}(= {{name}}_{{i}}_{{j}} {% if (i+1==j) %}true{%else%}false{%endif%}) {%endfor%}{%endfor%}{%endmacro%}
{% macro eq_char(s,m,c) %}{% for i in range(0,n+1) %}{% for j in range (i, n+1) %}(= {{m}}_{{i}}_{{j}} {% if (i+1==j) %}(= {{s}}_{{i}} {{c}}){%else%}false{%endif%}) {%endfor%}{%endfor%}{%endmacro%}

{% if comment is defined %}// {{ comment }}{% endif %}
// string length: {{ n }}
(synth-fun match_regex ( (len Int) {{ dec_str(s) }}) ((result Bool)) (
  Start : (Start.Sem(Term Int {{ t_str() }} Bool)) : t
  [({{ dec_mat(X) }}) (Start.Sem t len {{ str(s) }} result)]
  (
    // Evaluate regex on all substrings, return corner element
{% for k in range(0,n+1) %}
    (eval R:r) [ () (and (= t (Eval r)) (= len {{k}}) (R.Sem r len {{str(s)}} {{mat(X)}}) (= result {{X}}_0_{{k}}) ) ]
{% endfor %}
  )
)
(
  R : (R.Sem(Term Int {{ t_str() }} {{ t_mat() }})) : t
  [ ({{dec_mat(X)}}) (R.Sem t len {{str(s)}} {{mat(X)}}) ]
  (
    // epsilon: identity matrix (set of empty strings)
    eps [() (and (= t (Leaf 'eps')) {{eq_id(X)}} )]
    
{% if include_phi is defined and include_phi %}
    // phi: zero matrix (empty set)
    phi [() (and (= t (Leaf 'phi')) {{eq_false(X)}} )]
{% else %}
    // phi production is omitted
{% endif %}
    
    // characters
{% for c in charset %}
    char_{{c}} [() (and (= t (Leaf '{{c}}')) {{eq_char(s,X,c)}} )]
{% endfor %}

    // any (regex dot)
    any [() (and (= t (Leaf '.')) {{eq_any(X)}} )]
    
    // Disjunction
    (or R:t1 R:t2)
    [
        (
            {{dec_mat(A)}}
            {{dec_mat(B)}}
        )
        (and
            (= t (Or t1 t2))
            (R.Sem t1 len {{str(s)}} {{mat(A)}})
            (R.Sem t2 len {{str(s)}} {{mat(B)}})
            
            // X = A+B
            {%for i in range(0,n+1)%}{%for j in range(i, n+1)%}
            (= {{X}}_{{i}}_{{j}} (or {{A}}_{{i}}_{{j}} {{B}}_{{i}}_{{j}})){%endfor%}{%endfor%}
        )
    ]
    
    // Concatenation
    (concat R:t1 R:t2)
    [
        (
            {{dec_mat(A)}}
            {{dec_mat(B)}}
        )
        (and
            (= t (Concat t1 t2))
            (R.Sem t1 len {{str(s)}} {{mat(A)}})
            (R.Sem t2 len {{str(s)}} {{mat(B)}})
            
            // X = AB
            {%for i in range(0,n+1)%}{%for j in range(i, n+1)%}
            (= {{X}}_{{i}}_{{j}} (or {% for k in range(0, n+1)%}{% if i <= k and k <= j%}(and {{A}}_{{i}}_{{k}} {{B}}_{{k}}_{{j}}){%else%}                 {%endif%} {%endfor%})){%endfor%}{%endfor%}
        )
    ]
    
    // Star: base case
    (star R:t1)
    [ () (and (= t (Star t1)) (= len 0) {{eq_id(X)}} )]
    
    
// Logarithmic semantics
    
    // Star: inductive case (odd)
    //   Sem_R {<= k-1} () = M_{k-1}  Sem_R() = M
    //   ---------------------------------------- k-odd
    //   Sem_R {<= k} (...) = M_{k-1} (M + 1)
    
    (star R:t1)
    [
        (
            (kpr Int)
            {{dec_mat(A)}} // X
            {{dec_mat(B)}} // X_{k-1}
        )
        (and
            (= t (Star t1))
            (and (< 0 len) (= 1 (mod len 2)))
            (< 0 len)
            (= kpr (- len 1))
            (R.Sem t1 len {{str(s)}} {{mat(A)}})
            (R.Sem t  kpr {{str(s)}} {{mat(B)}})
            
            // X_{k} = X_{k-1} X
            {%for i in range(0,n+1)%}{%for j in range(i, n+1)%}
            (= {{X}}_{{i}}_{{j}} (or {{B}}_{{i}}_{{j}} {% for k in range(0, n+1)%}{% if i <= k and k <= j%}(and {{A}}_{{i}}_{{k}} {{B}}_{{k}}_{{j}}){%else%}                 {%endif%} {%endfor%})){%endfor%}{%endfor%}
        )
    ]    
    
    // Star: inductive case (even)
    //   Sem_{<= k/2} = M_{<= k/2}
    //   ------------------------------------------- k-even
    //   Sem_{<= k} = (M_{<= k/2})(M_{<= k/2})
        
    (star R:t1)
    [
        (
            (kpr Int)
            {{dec_mat(A)}} // X_{k/2}
        )
        (and
            (= t (Star t1))
            (and (< 0 len) (= 0 (mod len 2)))
            (= kpr (/ len 2))
            (R.Sem t  kpr {{str(s)}} {{mat(A)}})
            
            // X_{k} = (X_{k/2} X_{k/2})
            {%for i in range(0,n+1)%}{%for j in range(i, n+1)%}
            (= {{X}}_{{i}}_{{j}} (or {% for k in range(0, n+1)%}{% if i <= k and k <= j%}(and {{A}}_{{i}}_{{k}} {{A}}_{{k}}_{{j}}){%else%}                 {%endif%} {%endfor%})){%endfor%}{%endfor%}
        )
    ]
  )
)
)

{% if comment is defined %}// {{ comment }}{% endif %}

(constraint
    (and
    {%for example in examples %}
        (Start.Sem t {{ example.i | length }} {%for ival in example.i%}{{ival}} {%endfor%}{%for i in range(example.i | length,n)%}{{NA}} {%endfor%}{{example.o | lower}}){%endfor%}
    )
)