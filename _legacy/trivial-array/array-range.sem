
(synth-fun myfun ((x0 Int) (a0 IArray)) ((result IArray))
(
    Start : (Start.Sem(Term Int IArray IArray)) : t
    [() (Start.Sem t x0 a0 result)]
    (
        (Eval S:t1) [((x2 Int) (a2 IArray)) (and 
            (= t (Eval t1))
            (S.Sem t1 x0 a0 x2 a2)
            (= result a2)
        )]
        
    )
)
(
    S : (S.Sem (Term Int IArray Int IArray)) : t
    [((x2 Int) (a2 IArray)) (S.Sem t x0 a0 x2 a2)]
    (
        (While B:b S:s)
        [((v1 Bool) (x1 Int) (a1 IArray)) (and
            (= t (While b s))
            (B.Sem b x0 a0 v1) (= v1 true) // Condition evaluates to true under G0
            (S.Sem s x0 a0 x1 a1)       // G0 -> G1: assign G1 by evaluating s on G0
            (S.Sem t x1 a1 x2 a2)       // G1 -> G2: assign G2 by evaluating t on G1
        )]
        (While B:b S:s)
        [((v1 Bool)) (and
            (= t (While b s))
            (B.Sem b x0 a0 v1) (= v1 false) // Condition evaluates to false under G0
            (= x2 x0) (= a2 a0)      // G2 := G0; do not execute s
        )]
    
        (Assign_x E:t1) [((v1 Int)) (and 
            (= t (Assign 'x' t1))
            (E.Sem t1 x0 a0 v1)
            (= x2 v1) (= a2 a0)
        )]
        
        (Store_a E:t1 E:t2) [((v1 Int) (v2 Int)) (and 
            (= t (Store 'a' t1 t2))
            (E.Sem t1 x0 a0 v1)
            (E.Sem t2 x0 a0 v2)
            (= x2 x0) (= a2 (store a0 v1 v2))
        )]
        
        
        (Cons S:t1 S:t2) [((x1 Int) (a1 IArray)) (and
            (= t (Cons t1 t2))
            (S.Sem t1 x0 a0 x1 a1)
            (S.Sem t2 x1 a1 x2 a2)
        )]
    )
)
(
    E : (E.Sem (Term Int IArray Int)) : t  [((r Int)) (E.Sem t x0 a0 r)]
    (
        x [() (and (= t (Leaf 'x')) (= r x0))]
        0 [() (and (= t (Leaf '0')) (= r 0 ))]
        1 [() (and (= t (Leaf '1')) (= r 1 ))]
        (- E:t1 E:t2) [((v1 Int) (v2 Int)) (and (= t (Minus t1 t2)) (E.Sem t1 x0 a0 v1) (E.Sem t2 x0 a0 v2) (= r (- v1 v2)))]
    )
)
(
    B : (B.Sem (Term Int IArray Bool)) : t  [((r Bool)) (B.Sem t x0 a0 r)]
    (
        (LT E:t1 E:t2) [((v1 Int) (v2 Int)) (and (= t (LT t1 t2)) (E.Sem t1 x0 a0 v1) (E.Sem t2 x0 a0 v2) (= r (< v1 v2)))]
    )
)
)

// should produce (while (< 0 x0) (cons (store x0 x0) (assign_x (- x0 1))))
(constraint
    (and
        (Start.Sem t 0 (array.init 0) (array.init 0))
        (Start.Sem t 1 (array.init 0) (array.init 0 1))
        (Start.Sem t 2 (array.init 0) (array.init 0 1 2))
        (Start.Sem t 3 (array.init 0) (array.init 0 1 2 3))
        (Start.Sem t 4 (array.init 0) (array.init 0 1 2 3 4))
        (Start.Sem t 5 (array.init 0) (array.init 0 1 2 3 4 5))
    )
)
