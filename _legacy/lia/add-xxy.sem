(synth-fun xxy ((x Int) (y Int)) ((result Int)) // name, Inputs (x, y), Outputs (result)
(                                                // NT Start
  Start : (Start.Sem(Term Int Int Int)) : t      // NT name : relation-def : term name
  [() (Start.Sem t x y result)]                  // CHC conclusion
  (
    x [() (and (= t (Leaf 'x')) (= result x))]          // Leaf (x), with semantics for t and result.
    y [() (and (= t (Leaf 'y')) (= result y))]          // Using Leaf('y') to represent y as a term

    (+ Start:t1 Start:t2)
		[((v1 Int) (v2 Int)) (and (= t (Plus t1 t2)) (Start.Sem t1 x y v1) (Start.Sem t2 x y v2) (= result (+ v1 v2)))]
    // Premise for Plus: premise contains Start.Sems and computes v1 + v2 for result
  )
)
)

// Specification (will get translated into constraint => realizable + check realizable)
(constraint (and (Start.Sem t 3 5 11) (Start.Sem t 8 2 18)))
