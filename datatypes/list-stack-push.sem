
;;; Metadata
(set-info :format-version "2.0.0")
(set-info :author "Kanghee Park")
(set-info :realizable true)

;;;
;;; Datatypes
;;;
(declare-datatypes
  ((List 0) (Stack 0)) ; Intger List and Stack (may define generic List/Stack later)

  ((  ; Constructors for List
    ($nil)
    ($cons (hd Int) (tl List))
  )
  (   ; Constructor for Stack
    ($stack (list List))
  )) 
)

;;;
;;; Productions
;;;
(declare-term-types  
    ;; Term types  ; Declare terms inductively using syntactic constructors
    ((I 0) (B 0) (L 0) (ST 0))  ; Each term type corresponds to a nonterminal in the default grammar

    ;; Productions
    (( ; Productions for term type E
        ($x)
        ($0)
        ($1)
        ($+ I I)  ; The $+ production has two child terms of type E
        ($ite B I I)
    )
    ( ; Productions for term type B
        ($t) 
        ($f)
        ($not B)
        ($and B B)
        ($or B B)
        ($< I I)
    )
    ( ; Productions for term type L
        ($lnil)
        ($lcons I L)
        ($lsnoc L I)
        ($lreverse L)
        ($lappend L L)
        ($from_stack ST)
    )
    ( ; Productions for term type ST
        ($st)
        ($from_list L)
    )
  )
)

;;;
;;; Function Semantics
;;;
(define-funs-rec
  ;; Signatures
  (
    (snoc.Sem ((l List) (x Int) (rl List)) Bool)
    (reverse.Sem ((l List) (rl List)) Bool)
    (concat.Sem ((l1 List) (l2 List) (rl List)) Bool)
  )
  ;; Bodies
  (
    (! ; snoc semantics
      (match l
        ($nil (= rl (cons x nil)))
        (($cons hd tl)
          (exists (rsub List)
            (and
              (snoc.Sem tl x rsub)
              (= rl (cons hd rsub)))))
      )
      :input (l x) :output (rl)
    )

    (!  ; reverse semantics
      (match l
        ($nil (= rl nil))
        (($cons hd tl)
          (exists (rsub List)
            (and
              (reverse.Sem tl rsub)
              (snoc.Sem hd rsub rl))))
      )
      :input (l) :output (rl)
    )

    (!  ; append semantics
      (match l1
        ($nil (= rl l2))
        (($cons hd tl)
          (exists (rsub List)
            (and
              (append.Sem tl l2 rsub)
              (= rl (cons hd rsub)))))
      )
      :input (l x) :output (rl)
    ))
)

;;;
;;; Term Semantics
;;;
(define-funs-rec
  ;; Semantic relations and their types
  (
    (I.Sem ((it I) (x Int) (st Stack) (r Int)) Bool)  ; Each relation is declared as a function Sem : (members) -> Bool
    (B.Sem ((bt B) (x Int) (st Stack) (r Bool)) Bool) ; The `_.Sem` names are a naming convention with no special significance.
    (L.Sem ((lt L) (x Int) (st Stack) (r List)) Bool)
    (ST.Sem ((stt L) (x Int) (st Stack) (r Stack)) Bool)
  )
  ;; Bodies
  (
    (! ; The `!` expression attaches attributes to its first argument: in this case, the `:in` and `:out` labels below
      (match it ; I.Sem defined inductively through matching
        ($x (= r x))
        ($0 (= r 0))
        ($1 (= r 1))
        (($+ it1 it2)
          (exists ((r1 Int) (r2 Int))
            (and
              (I.Sem it1 x st r1)
              (I.Sem it2 x st r2)
              (= r (+ r1 r2)))))
        (($ite bt it1 it2)
          (exists ((b Bool)) 
            (and
              (B.Sem bt x st b)
              (= b true)
              (I.Sem it1 x st r)))
          (exists ((b Bool))
            (and
              (B.Sem bt x st b)
              (= b false)
              (I.Sem it2 x st r))))
      ) ; end `match it`
      :input (x st) :output (r)
    )                               

    (!(match bt ; B.Sem definitions
        (($t (= r true))
        ($f (= r false))
        (($not bt1)
          (exists ((rb Bool))
            (and
              (B.Sem bt1 x y rb)
              (= r (not rb)))))
        (($and bt1 bt2)
          (exists ((rb1 Bool) (rb2 Bool))
            (and
              (B.Sem bt1 x y rb1)
              (B.Sem bt2 x y rb2)
              (= r (and rb1 rb2)))))
        (($or bt1 bt2)
          (exists ((rb1 Bool) (rb2 Bool))
            (and
              (B.Sem bt1 x y rb1)
              (B.Sem bt2 x y rb2)
              (= r (or rb1 rb2)))))
        (($< et1 et2)
          (exists ((r1 Int) (r2 Int))
            (and
              (E.Sem et1 x y r1)
              (E.Sem et2 x y r2)
              (= r (< r1 r2))))))
      ) ; end `match bt`
      :input (x st) :output (r)
    )

    (!(match lt ; L.Sem definitions
        (($lnil (= r nil))
        (($lcons it lt1) 
          (exists ((ri Int) (rl List))
            (and
              (I.Sem it x st ri)
              (L.Sem lt1 x st rl)
              (= r (cons ri rl)))))
        (($lsnoc lt1 it)
          (exists ((ri Int) (rl List))
            (and
              (I.Sem it x st ri)
              (L.Sem lt1 x st rl)
              (snoc.Sem rl ri r))))
        (($lreverse lt)
          (exists ((rl List))
            (and
              (L.Sem lt x st rl)
              (reverse.Sem rl r))))
        (($lappend lt1 lt2)
          (exists ((rl1 List) (rl2 List)) 
            (and
              (L.Sem lt1 x st rl1)
              (L.Sem lt2 x st rl2)
              (append.Sem rl1 rl2 r))))
        (($from_stack stt)
          (exists ((rst Stack))
            (and 
              (ST.Sem stt x st rst)
              (= r (list rst)))))
      ) ; end `match lt`
      :input (x st) :output (r)
    )

    (!(match stt ; ST.Sem definitions
          (($st (= r st))
          (($from_list lt)
            (exists ((rl List))
              (and
                (L.Sem lt x st rl)
                (= r (stack rl)))))
      ) ; end `match stt`
      :input (x st) :output (r)
    ))
)

;;;
;;; Function to synthesize
;;;
(synth-fun push() ST)


;;;
;;; Constraints 
;;;

;;; To-Do