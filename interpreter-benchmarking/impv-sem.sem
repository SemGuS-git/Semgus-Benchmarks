(synth-fun myfun ((x0 Int) (y0 Int) (c0 Int)) ((result Int))
(
  Start : (Start.Sem (Term Int Int Int Int)) : t
  [((x2 Int) (y2 Int) (c2 Int)) (Start.Sem t x0 y0 c0 result)]
  (
      (Eval S:t1)
      [() (and
        (= t (Eval t1))
        (S.Sem t1 x0 y0 c0 x2 y2 c2)
        (= result c2)
      )]
  )
)
(
  S : (S.Sem(Term Int Int Int Int Int Int)) : t // Statement
  [((x2 Int) (y2 Int) (c2 Int)) (S.Sem t x0 y0 c0 x2 y2 c2)]
  (
    
    (assign x E:t1) [((v1 Int)) (and 
        (= t (Assign 'x' t1))
        (E.Sem t1 x0 y0 c0 v1)
        (= x2 v1) (= y2 y0) (= c2 c0)
    )]
    
    (assign y E:t1) [((v1 Int)) (and 
        (= t (Assign 'y' t1))
        (E.Sem t1 x0 y0 c0 v1)
        (= x2 x0) (= y2 v1) (= c2 c0)
    )]
    
    (assign c E:t1) [((v1 Int)) (and 
        (= t (Assign 'c' t1))
        (E.Sem t1 x0 y0 c0 v1)
        (= x2 x0) (= y2 y0) (= c2 v1)
    )]
    
    (seq S:t1 S:t2)
    [((x1 Int) (y1 Int) (c1 Int)) (and
        (= t (Seq t1 t2))
        (S.Sem t1 x0 y0 c0 x1 y1 c1)
        (S.Sem t2 x1 y1 c1 x2 y2 c2)
    )]
    
    (while B:b S:s)
    [((v1 Bool) (x1 Int) (y1 Int) (c1 Int)) (and
        (= t (While b s))
        (B.Sem b x0 y0 c0 v1) (= v1 true) // Condition evaluates to true under G0
        (S.Sem s x0 y0 c0 x1 y1 c1)       // G0 -> G1: assign G1 by evaluating s on G0
        (S.Sem t x1 y1 c1 x2 y2 c2)       // G1 -> G2: assign G2 by evaluating t on G1
    )]
    (while B:b S:s)
    [((v1 Bool)) (and
        (= t (While b s))
        (B.Sem b x0 y0 c0 v1) (= v1 false) // Condition evaluates to false under G0
        (= x2 x0) (= y2 y0) (= c2 c0)      // G2 := G0; do not execute s
    )]
    
    (site B:b S:t1 S:t2)
    [((v1 Bool)) (and 
        (= t (SITE b t1 t2))
        (B.Sem b x0 y0 c0 v1)
        (= v1 true)
        (S.Sem t1 x0 y0 c0 x2 y2 c2) // execute true branch only
    )]
    (site B:b S:t1 S:t2)
    [((v1 Bool)) (and 
        (= t (SITE b t1 t2))
        (B.Sem b x0 y0 c0 v1)
        (= v1 false)
        (S.Sem t2 x0 y0 c0 x2 y2 c2) // execute false branch only
    )]
  )
)
(
  E : (E.Sem(Term Int Int Int Int)) : t
  [((r Int)) (E.Sem t x0 y0 c0 r)]
  (
    x [() (and (= t (Leaf 'x')) (= r x0))]
    y [() (and (= t (Leaf 'y')) (= r y0))]
    c [() (and (= t (Leaf 'c')) (= r c0))]
    0 [() (and (= t (Leaf '0')) (= r 0))]
    1 [() (and (= t (Leaf '1')) (= r 1))]
    (+ E:t1 E:t2) [((v1 Int) (v2 Int)) (and (= t (Plus  t1 t2)) (E.Sem t1 x0 y0 c0 v1) (E.Sem t2 x0 y0 c0 v2) (= r (+ v1 v2)))]
    (- E:t1 E:t2) [((v1 Int) (v2 Int)) (and (= t (Minus t1 t2)) (E.Sem t1 x0 y0 c0 v1) (E.Sem t2 x0 y0 c0 v2) (= r (- v1 v2)))]
  )
)
(
  B : (B.Sem(Term Int Int Int Bool)) : t
  [((r Bool)) (B.Sem t x0 y0 c0 r)]
  (
    true  [() (and (= t (Leaf 'true'))  (= r true ))]
    false [() (and (= t (Leaf 'false')) (= r false))]
    
    (! B:t1) [((v1 Bool)) (and (= t (Not t1)) (B.Sem t1 x0 y0 c0 v1) (= r (! v1)))]

    (and B:t1 B:t2) [((v1 Bool) (v2 Bool)) (and (= t (And t1 t2)) (B.Sem t1 x0 y0 c0 v1) (B.Sem t2 x0 y0 c0 v2) (= r (and v1 v2)))]
    (LT  E:t1 E:t2) [((v1 Int ) (v2 Int )) (and (= t (LT  t1 t2)) (E.Sem t1 x0 y0 c0 v1) (E.Sem t2 x0 y0 c0 v2) (= r (<   v1 v2)))]
  )
)