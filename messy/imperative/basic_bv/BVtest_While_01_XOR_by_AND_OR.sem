// AUTO GENERATED by ImperativeExampleConverter from basic_bv.json
// BVtest_While_01_XOR_by_AND_OR
(synth-fun _max ((x BitVec) (y BitVec)) ((x_out BitVec))

(
    _Entry : (_Entry.Sem (Term BitVec BitVec BitVec)) : t
    [() (_Entry.Sem t x y x_out)]
    (
        (Eval Start:_term0) [( (y_out BitVec)) (and
            (= t (Eval _term0))
            (Start.Sem _term0 x y x_out y_out)
        )]
    )
)
(

    Start : (Start.Sem (Term BitVec BitVec BitVec BitVec)) : t
    [( (y_out BitVec)) (Start.Sem t x y x_out y_out)]
    (

        // Start ::= While @B @S

        (prod0 B:_term0 S:_term1) [((_cond Bool) (x_temp BitVec) (y_temp BitVec)) (and
            (= t (While _term0 _term1))
            (B.Sem _term0 x y _cond)
            (= _cond true)
            (S.Sem _term1 x y x_temp y_temp)
            (Start.Sem t x_temp y_temp x_out y_out)
        )]
        (prod0 B:_term0 S:_term1) [((_cond Bool)) (and
            (= t (While _term0 _term1))
            (B.Sem _term0 x y _cond)
            (= _cond false)
            (= x_out x) (= y_out y)
        )]
    )
)
(

    E1 : (E1.Sem (Term BitVec BitVec BitVec)) : t
    [( (_result BitVec)) (E1.Sem t x y _result)]
    (

        // E1 ::= BVSingleTerm $x

        prod3 [() (and (= t (Leaf 'x')) (= _result x))]

        // E1 ::= BVSingleTerm $y

        prod4 [() (and (= t (Leaf 'y')) (= _result y))]

        // E1 ::= BVAnd @E1 @E1

        (prod5 E1:_term0 E1:_term1) [((_term0_val BitVec) (_term1_val BitVec)) (and
            (= t (BVAnd _term0 _term1))
            (E1.Sem _term0 x y _term0_val) (E1.Sem _term1 x y _term1_val)
            (= _result (bvand _term0_val _term1_val))
        )]

        // E1 ::= BVOr @E1 @E1

        (prod6 E1:_term0 E1:_term1) [((_term0_val BitVec) (_term1_val BitVec)) (and
            (= t (BVOr _term0 _term1))
            (E1.Sem _term0 x y _term0_val) (E1.Sem _term1 x y _term1_val)
            (= _result (bvor _term0_val _term1_val))
        )]
    )
)
(

    S : (S.Sem (Term BitVec BitVec BitVec BitVec)) : t
    [( (y_out BitVec)) (S.Sem t x y x_out y_out)]
    (

        // S ::= BVAssign $x @E1

        (prod2 E1:_term0) [((_temp BitVec)) (and 
            (= t (BVAssign 'x' _term0))
            (E1.Sem _term0 x y _temp)
            (= x_out _temp) (= y_out y)
        )]

        // S ::= Seq @S @S

        (prod7 S:_term0 S:_term1) [((x_temp BitVec) (y_temp BitVec)) (and
            (= t (Seq _term0 _term1))
            (S.Sem _term0 x y x_temp y_temp)
            (S.Sem _term1 x_temp y_temp x_out y_out)
        )]

        // S ::= BVAssign $y @E1

        (prod8 E1:_term0) [((_temp BitVec)) (and 
            (= t (BVAssign 'y' _term0))
            (E1.Sem _term0 x y _temp)
            (= x_out x) (= y_out _temp)
        )]
    )
)
(

    B : (B.Sem (Term BitVec BitVec Bool)) : t
    [( (_result Bool)) (B.Sem t x y _result)]
    (

        // B ::= BVUlt @E1 @E1

        (prod1 E1:_term0 E1:_term1) [((_term0_val BitVec) (_term1_val BitVec)) (and
            (= t (BVUlt _term0 _term1))
            (E1.Sem _term0 x y _term0_val) (E1.Sem _term1 x y _term1_val)
            (= _result (bvult _term0_val _term1_val))
        )]
    )
)
)

(constraint
    (and
        (_Entry.Sem t #x00000006 #x00000009 #x0000000f) // { x: 6, y: 9, } -> { x: 15, }
        (_Entry.Sem t #x000000f7 #x0000002c #x000000db) // { x: 247, y: 44, } -> { x: 219, }
        (_Entry.Sem t #x0000000e #x0000000f #x00000001) // { x: 14, y: 15, } -> { x: 1, }
    )
)
