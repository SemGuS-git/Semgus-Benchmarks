// AUTO GENERATED by ImperativeExampleConverter from basic_1.json
// minimal_unsat
(synth-fun _mini ((x Int) (n Int)) ((x_out Int))

(
    _Entry : (_Entry.Sem (Term Int Int Int)) : t
    [() (_Entry.Sem t x n x_out)]
    (
        (Eval Start:_term0) [( (n_out Int)) (and
            (= t (Eval _term0))
            (Start.Sem _term0 x n x_out n_out)
        )]
    )
)
(

    Start : (Start.Sem (Term Int Int Int Int)) : t
    [( (n_out Int)) (Start.Sem t x n x_out n_out)]
    (

        // Start ::= While @B @S

        (prod0 B:_term0 S:_term1) [((_cond Bool) (x_temp Int) (n_temp Int)) (and
            (= t (While _term0 _term1))
            (B.Sem _term0 x n _cond)
            (= _cond true)
            (S.Sem _term1 x n x_temp n_temp)
            (Start.Sem t x_temp n_temp x_out n_out)
        )]
        (prod0 B:_term0 S:_term1) [((_cond Bool)) (and
            (= t (While _term0 _term1))
            (B.Sem _term0 x n _cond)
            (= _cond false)
            (= x_out x) (= n_out n)
        )]
    )
)
(

    S : (S.Sem (Term Int Int Int Int)) : t
    [( (n_out Int)) (S.Sem t x n x_out n_out)]
    (

        // S ::= Seq @S1 @S2

        (prod1 S1:_term0 S2:_term1) [((x_temp Int) (n_temp Int)) (and
            (= t (Seq _term0 _term1))
            (S1.Sem _term0 x n x_temp n_temp)
            (S2.Sem _term1 x_temp n_temp x_out n_out)
        )]
    )
)
(

    B : (B.Sem (Term Int Int Bool)) : t
    [( (_result Bool)) (B.Sem t x n _result)]
    (

        // B ::= LT 1 $n

        prod5 [() (and
            (= t (LT '1' 'n'))
            
            (= _result (< 1 n))
        )]
    )
)
(

    A : (A.Sem (Term Int Int Int)) : t
    [( (_result Int)) (A.Sem t x n _result)]
    (

        // A ::= IntSingleTerm $x

        prod8 [() (and (= t (Leaf 'x')) (= _result x))]
    )
)
(

    S2 : (S2.Sem (Term Int Int Int Int)) : t
    [( (n_out Int)) (S2.Sem t x n x_out n_out)]
    (

        // S2 ::= IntAssign $n 1

        prod3 [((_temp Int)) (and 
            (= t (IntAssign 'n' '1'))
            (= _temp 1)
            (= x_out x) (= n_out _temp)
        )]
    )
)
(

    E : (E.Sem (Term Int Int Int)) : t
    [( (_result Int)) (E.Sem t x n _result)]
    (

        // E ::= Plus @A @A

        (prod6 A:_term0 A:_term1) [((_term0_val Int) (_term1_val Int)) (and
            (= t (Plus _term0 _term1))
            (A.Sem _term0 x n _term0_val) (A.Sem _term1 x n _term1_val)
            (= _result (+ _term0_val _term1_val))
        )]

        // E ::= Minus @A @A

        (prod4 A:_term0 A:_term1) [((_term0_val Int) (_term1_val Int)) (and
            (= t (Minus _term0 _term1))
            (A.Sem _term0 x n _term0_val) (A.Sem _term1 x n _term1_val)
            (= _result (- _term0_val _term1_val))
        )]
    )
)
(

    S1 : (S1.Sem (Term Int Int Int Int)) : t
    [( (n_out Int)) (S1.Sem t x n x_out n_out)]
    (

        // S1 ::= IntAssign $x @E

        (prod2 E:_term0) [((_temp Int)) (and 
            (= t (IntAssign 'x' _term0))
            (E.Sem _term0 x n _temp)
            (= x_out _temp) (= n_out n)
        )]
    )
)
)

(constraint
    (and
        (_Entry.Sem t 5 4 2)
    )
)
