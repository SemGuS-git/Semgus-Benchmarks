// AUTO GENERATED by ImperativeExampleConverter from basic_1.json
// basicTest_MAX_03
(synth-fun _max ((x Int) (y Int) (c Int)) ((x_out Int) (y_out Int))

(
    _Entry : (_Entry.Sem (Term Int Int Int Int Int)) : t
    [() (_Entry.Sem t x y c x_out y_out)]
    (
        (Eval Start:_term0) [( (c_out Int)) (and
            (= t (Eval _term0))
            (Start.Sem _term0 x y c x_out y_out c_out)
        )]
    )
)
(

    E : (E.Sem (Term Int Int Int Int)) : t
    [( (_result Int)) (E.Sem t x y c _result)]
    (

        // E ::= IntSingleTerm $c

        prod8 [() (and (= t (Leaf 'c')) (= _result c))]

        // E ::= EITE @B @E @E

        (prod5 B:_term0 E:_term1 E:_term2) [((_term0_val Bool) (_term1_val Int) (_term2_val Int)) (and
            (= t (EITE _term0 _term1 _term2))
            (B.Sem _term0 x y c _term0_val) (E.Sem _term1 x y c _term1_val) (E.Sem _term2 x y c _term2_val)
            (= _result (ite _term0_val _term1_val _term2_val))
        )]

        // E ::= IntSingleTerm $x

        prod3 [() (and (= t (Leaf 'x')) (= _result x))]

        // E ::= IntSingleTerm $y

        prod4 [() (and (= t (Leaf 'y')) (= _result y))]
    )
)
(

    Start : (Start.Sem (Term Int Int Int Int Int Int)) : t
    [( (c_out Int)) (Start.Sem t x y c x_out y_out c_out)]
    (

        // Start ::= IntAssign $c @E

        (prod7 E:_term0) [((_temp Int)) (and 
            (= t (IntAssign 'c' _term0))
            (E.Sem _term0 x y c _temp)
            (= x_out x) (= y_out y) (= c_out _temp)
        )]

        // Start ::= IntAssign $x @E

        (prod0 E:_term0) [((_temp Int)) (and 
            (= t (IntAssign 'x' _term0))
            (E.Sem _term0 x y c _temp)
            (= x_out _temp) (= y_out y) (= c_out c)
        )]

        // Start ::= Seq @Start @Start

        (prod6 Start:_term0 Start:_term1) [((x_temp Int) (y_temp Int) (c_temp Int)) (and
            (= t (Seq _term0 _term1))
            (Start.Sem _term0 x y c x_temp y_temp c_temp)
            (Start.Sem _term1 x_temp y_temp c_temp x_out y_out c_out)
        )]

        // Start ::= IntAssign $y @E

        (prod1 E:_term0) [((_temp Int)) (and 
            (= t (IntAssign 'y' _term0))
            (E.Sem _term0 x y c _temp)
            (= x_out x) (= y_out _temp) (= c_out c)
        )]
    )
)
(

    B : (B.Sem (Term Int Int Int Bool)) : t
    [( (_result Bool)) (B.Sem t x y c _result)]
    (

        // B ::= LT @E @E

        (prod2 E:_term0 E:_term1) [((_term0_val Int) (_term1_val Int)) (and
            (= t (LT _term0 _term1))
            (E.Sem _term0 x y c _term0_val) (E.Sem _term1 x y c _term1_val)
            (= _result (< _term0_val _term1_val))
        )]
    )
)
)

(constraint
    (and
        (_Entry.Sem t 4 1 0 4 1) // { x: 4, y: 1, } -> { x: 4, y: 1, }
        (_Entry.Sem t 2 6 0 6 2) // { x: 2, y: 6, } -> { x: 6, y: 2, }
        (_Entry.Sem t 1 1 0 1 1) // { x: 1, y: 1, } -> { x: 1, y: 1, }
        (_Entry.Sem t 8 8 0 8 8) // { x: 8, y: 8, } -> { x: 8, y: 8, }
    )
)
