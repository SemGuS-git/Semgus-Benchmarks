// AUTO GENERATED by ImperativeExampleConverter from basic_1.json
// basicTest21_one_way_loop
(synth-fun _mini ((x Int) (n Int)) ((x_out Int))

(
    _Entry : (_Entry.Sem (Term Int Int Int)) : t
    [() (_Entry.Sem t x n x_out)]
    (
        (Eval Start:_term0) [( (n_out Int)) (and
            (= t (Eval _term0))
            (Start.Sem _term0 x n x_out n_out)
        )]
    )
)
(

    B : (B.Sem (Term Int Int Bool)) : t
    [( (_result Bool)) (B.Sem t x n _result)]
    (

        // B ::= LT 1 $n

        prod5 [() (and
            (= t (LT '1' 'n'))
            
            (= _result (< 1 n))
        )]
    )
)
(

    S2 : (S2.Sem (Term Int Int Int Int)) : t
    [( (n_out Int)) (S2.Sem t x n x_out n_out)]
    (

        // S2 ::= IntAssign $n @M

        (prod3 M:_term0) [((_temp Int)) (and 
            (= t (IntAssign 'n' _term0))
            (M.Sem _term0 x n _temp)
            (= x_out x) (= n_out _temp)
        )]
    )
)
(

    SMinus : (SMinus.Sem (Term Int Int Int Int)) : t
    [( (n_out Int)) (SMinus.Sem t x n x_out n_out)]
    (

        // SMinus ::= IntAssign $x @EMinus

        (prod12 EMinus:_term0) [((_temp Int)) (and 
            (= t (IntAssign 'x' _term0))
            (EMinus.Sem _term0 x n _temp)
            (= x_out _temp) (= n_out n)
        )]

        // SMinus ::= Seq @SMinus @SMinus

        (prod17 SMinus:_term0 SMinus:_term1) [((x_temp Int) (n_temp Int)) (and
            (= t (Seq _term0 _term1))
            (SMinus.Sem _term0 x n x_temp n_temp)
            (SMinus.Sem _term1 x_temp n_temp x_out n_out)
        )]
    )
)
(

    SPlus : (SPlus.Sem (Term Int Int Int Int)) : t
    [( (n_out Int)) (SPlus.Sem t x n x_out n_out)]
    (

        // SPlus ::= IntAssign $x @EPlus

        (prod11 EPlus:_term0) [((_temp Int)) (and 
            (= t (IntAssign 'x' _term0))
            (EPlus.Sem _term0 x n _temp)
            (= x_out _temp) (= n_out n)
        )]

        // SPlus ::= Seq @SPlus @SPlus

        (prod16 SPlus:_term0 SPlus:_term1) [((x_temp Int) (n_temp Int)) (and
            (= t (Seq _term0 _term1))
            (SPlus.Sem _term0 x n x_temp n_temp)
            (SPlus.Sem _term1 x_temp n_temp x_out n_out)
        )]
    )
)
(

    S : (S.Sem (Term Int Int Int Int)) : t
    [( (n_out Int)) (S.Sem t x n x_out n_out)]
    (

        // S ::= Seq @SMinus @S2

        (prod9 SMinus:_term0 S2:_term1) [((x_temp Int) (n_temp Int)) (and
            (= t (Seq _term0 _term1))
            (SMinus.Sem _term0 x n x_temp n_temp)
            (S2.Sem _term1 x_temp n_temp x_out n_out)
        )]

        // S ::= Seq @SPlus @S2

        (prod1 SPlus:_term0 S2:_term1) [((x_temp Int) (n_temp Int)) (and
            (= t (Seq _term0 _term1))
            (SPlus.Sem _term0 x n x_temp n_temp)
            (S2.Sem _term1 x_temp n_temp x_out n_out)
        )]
    )
)
(

    EMinus : (EMinus.Sem (Term Int Int Int)) : t
    [( (_result Int)) (EMinus.Sem t x n _result)]
    (

        // EMinus ::= Minus $x 1

        prod14 [() (and
            (= t (Minus 'x' '1'))
            
            (= _result (- x 1))
        )]
    )
)
(

    Start : (Start.Sem (Term Int Int Int Int)) : t
    [( (n_out Int)) (Start.Sem t x n x_out n_out)]
    (

        // Start ::= While @B @S

        (prod0 B:_term0 S:_term1) [((_cond Bool) (x_temp Int) (n_temp Int)) (and
            (= t (While _term0 _term1))
            (B.Sem _term0 x n _cond)
            (= _cond true)
            (S.Sem _term1 x n x_temp n_temp)
            (Start.Sem t x_temp n_temp x_out n_out)
        )]
        (prod0 B:_term0 S:_term1) [((_cond Bool)) (and
            (= t (While _term0 _term1))
            (B.Sem _term0 x n _cond)
            (= _cond false)
            (= x_out x) (= n_out n)
        )]
    )
)
(

    M : (M.Sem (Term Int Int Int)) : t
    [( (_result Int)) (M.Sem t x n _result)]
    (

        // M ::= Minus $n 1

        prod10 [() (and
            (= t (Minus 'n' '1'))
            
            (= _result (- n 1))
        )]
    )
)
(

    EPlus : (EPlus.Sem (Term Int Int Int)) : t
    [( (_result Int)) (EPlus.Sem t x n _result)]
    (

        // EPlus ::= Plus $x 1

        prod13 [() (and
            (= t (Plus 'x' '1'))
            
            (= _result (+ x 1))
        )]
    )
)
)

(constraint
    (and
        (_Entry.Sem t 5 2 6)
        (_Entry.Sem t 6 2 5)
    )
)
