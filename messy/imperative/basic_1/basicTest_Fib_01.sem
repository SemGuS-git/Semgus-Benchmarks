// basicTest_Fib_01
(synth-fun _gcd ((x Int) (y Int) (i Int)) ((x_out Int))

(
    _Entry : (_Entry.Sem (Term Int Int Int Int)) : t
    [() (_Entry.Sem t x y i x_out)]
    (
        (Eval Start:_term0) [( (y_out Int) (i_out Int)) (and
            (= t (Eval _term0))
            (Start.Sem _term0 x y i x_out y_out i_out)
        )]
    )
)
(

    S : (S.Sem (Term Int Int Int Int Int Int)) : t
    [( (y_out Int) (i_out Int)) (S.Sem t x y i x_out y_out i_out)]
    (

        // S ::= IntAssign $i @E1

        (prod4 E1:_term0) [((_temp Int)) (and 
            (= t (IntAssign 'i' _term0))
            (E1.Sem _term0 x y i _temp)
            (= x_out x) (= y_out y) (= i_out _temp)
        )]

        // S ::= IntAssign $x @E

        (prod1 E:_term0) [((_temp Int)) (and 
            (= t (IntAssign 'x' _term0))
            (E.Sem _term0 x y i _temp)
            (= x_out _temp) (= y_out y) (= i_out i)
        )]

        // S ::= Seq @S @S

        (prod3 S:_term0 S:_term1) [((x_temp Int) (y_temp Int) (i_temp Int)) (and
            (= t (Seq _term0 _term1))
            (S.Sem _term0 x y i x_temp y_temp i_temp)
            (S.Sem _term1 x_temp y_temp i_temp x_out y_out i_out)
        )]
    )
)
(

    E1 : (E1.Sem (Term Int Int Int Int)) : t
    [( (_result Int)) (E1.Sem t x y i _result)]
    (

        // E1 ::= IntSingleTerm $i

        prod12 [() (and (= t (Leaf 'i')) (= _result i))]

        // E1 ::= IntSingleTerm 1

        prod13 [() (and (= t (Leaf '1')) (= _result 1))]
    )
)
(

    E : (E.Sem (Term Int Int Int Int)) : t
    [( (_result Int)) (E.Sem t x y i _result)]
    (

        // E ::= IntSingleTerm 1

        prod9 [() (and (= t (Leaf '1')) (= _result 1))]

        // E ::= IntSingleTerm $x

        prod7 [() (and (= t (Leaf 'x')) (= _result x))]

        // E ::= Plus @E @E

        (prod6 E:_term0 E:_term1) [((_term0_val Int) (_term1_val Int)) (and
            (= t (Plus _term0 _term1))
            (E.Sem _term0 x y i _term0_val) (E.Sem _term1 x y i _term1_val)
            (= _result (+ _term0_val _term1_val))
        )]

        // E ::= IntSingleTerm $y

        prod8 [() (and (= t (Leaf 'y')) (= _result y))]
    )
)
(

    E2 : (E2.Sem (Term Int Int Int Int)) : t
    [( (_result Int)) (E2.Sem t x y i _result)]
    (

        // E2 ::= IntSingleTerm 2

        prod10 [() (and (= t (Leaf '2')) (= _result 2))]

        // E2 ::= IntSingleTerm $i

        prod11 [() (and (= t (Leaf 'i')) (= _result i))]
    )
)
(

    Start : (Start.Sem (Term Int Int Int Int Int Int)) : t
    [( (y_out Int) (i_out Int)) (Start.Sem t x y i x_out y_out i_out)]
    (

        // Start ::= Seq @S @S

        (prod0 S:_term0 S:_term1) [((x_temp Int) (y_temp Int) (i_temp Int)) (and
            (= t (Seq _term0 _term1))
            (S.Sem _term0 x y i x_temp y_temp i_temp)
            (S.Sem _term1 x_temp y_temp i_temp x_out y_out i_out)
        )]
    )
)
(

    B1 : (B1.Sem (Term Int Int Int Bool)) : t
    [( (_result Bool)) (B1.Sem t x y i _result)]
    (

        // B1 ::= LT @E2 @E2

        (prod5 E2:_term0 E2:_term1) [((_term0_val Int) (_term1_val Int)) (and
            (= t (LT _term0 _term1))
            (E2.Sem _term0 x y i _term0_val) (E2.Sem _term1 x y i _term1_val)
            (= _result (< _term0_val _term1_val))
        )]
    )
)
)

(constraint
    (and
        (_Entry.Sem t 1 1 1 1)
        (_Entry.Sem t 1 1 5 5)
        (_Entry.Sem t 1 1 10 55)
    )
)
