// AUTO GENERATED by ImperativeExampleConverter from constantTests.json
// constantTest01
(synth-fun const ((x Int)) ((x_out Int))

(
    _Entry : (_Entry.Sem (Term Int Int)) : t
    [() (_Entry.Sem t x x_out)]
    (
        (Eval Start:_term0) [( ) (and
            (= t (Eval _term0))
            (Start.Sem _term0 x x_out)
        )]
    )
)
(

    Start : (Start.Sem (Term Int Int)) : t
    [( ) (Start.Sem t x x_out)]
    (

        // Start ::= IntAssign $x @E

        (prod0 E:_term0) [((_temp Int)) (and 
            (= t (IntAssign 'x' _term0))
            (E.Sem _term0 x _temp)
            (= x_out _temp)
        )]
    )
)
(

    E : (E.Sem (Term Int Int)) : t
    [( (_result Int)) (E.Sem t x _result)]
    (

        // E ::= Plus @E @E

        (prod1 E:_term0 E:_term1) [((_term0_val Int) (_term1_val Int)) (and
            (= t (Plus _term0 _term1))
            (E.Sem _term0 x _term0_val) (E.Sem _term1 x _term1_val)
            (= _result (+ _term0_val _term1_val))
        )]

        // E ::= IntSingleTerm $x

        prod2 [() (and (= t (Leaf 'x')) (= _result x))]

        // E ::= IntSingleTerm 4123

        prod3 [() (and (= t (Leaf '4123')) (= _result 4123))]
    )
)
)

(constraint
    (and
        (_Entry.Sem t 0 3268)
        (_Entry.Sem t 642 3910)
    )
)
